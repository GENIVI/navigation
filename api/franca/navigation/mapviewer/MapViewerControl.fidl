// SPDX-License-Identifier: MPL-2.0
// Copyright (C) 2014, PCA Peugeot Citroï¿½n, XS Embedded GmbH, TomTom International B.V., Continental Automotive GmbH, BMW Car IT GmbH,  Alpine Electronics R&D Europe GmbH, AISIN AW CO., LTD.,  Neusoft Technology Solutions GmbH, Jaguar Land Rover Limited, Visteon Corporation, Elektrobit Automotive GmbH
// This Source Code Form is subject to the terms of the
// Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with
// this file, you can obtain one at http://mozilla.org/MPL/2.0/.

package org.genivi.navigation.mapviewer

import org.genivi.CommonTypes.* from "../../CommonTypes.fidl"
import org.genivi.navigation.NavigationTypes.* from "../NavigationTypes.fidl"

<**
	@description : MapViewerControl = This interface offers functions to control the MapViewer
**>
interface MapViewerControl {
	version {
		major 4 
		minor 0
	}
	
	enumeration MapViewType extends BasicEnum { //Base 0x0010
		MAIN_MAP		= 16
		SPLIT_SCREEN	= 17		
		GUIDING_MAP		= 18
	}
	
	enumeration MapScaleMode extends BasicEnum { //Base 0x0110
		AUTOMATIC		= 272
		MANUAL			= 273
		HYBRID			= 274
	}

	enumeration MapPerspective extends BasicEnum { //Base 0x0020
		PERSPECTIVE_2D	= 32
		PERSPECTIVE_3D	= 33
	}

	enumeration MapObject extends BasicEnum {
		// TODO: Check which elements are really visible
		BUILDINGS 			= 128	
		TERRAIN 			= 129
		DET_POI                           //Points Of Interest
		DET_TTI                           //TTI elements
		DET_ONE_WAY_STREET_ARROW          //Arrows marking one way streets
		DET_CITY_NAME                     //City names
		DET_ROAD_NAME                     //Road names
		DET_MOTORWAY_EXIT_MARKER          //Motorway exit signs
		DET_TRAFFIC_LIGHT                 //Traffic lights
		DET_TRAFFIC_LIGHTS_ALONG_ROUTE    //Traffic lights along the route
		DET_ROAD_ICON                     //Road icons
		DET_DTM                           //Digital Terrain Model
		DET_LANDMARKS_3D                  //3D landmarks
		DET_FAVORITES                     //Saved favorite destinations
		DET_ROUTE_BLOCKING                //Highlighting of blocked routes
		DET_ROAD                          //Roads
		DET_POLYGON                       //Polygons
		DET_DESTINATION                   //Destination flag
		DET_MANOEUVRE_MARKER              //Maneuvre point markers
		DET_LANE_GUIDANCE_MARKER          //Lane guidance point markers
		DET_ROUTE                         //Route
		DET_MANOEUVRE_ARROW               //Maneuvre arrows
		DET_TREKKING_TOUR                 //Trekking tours
		DET_TTI_EDGE_HIGHLIGHTING         //TTI highlighted edges
		DET_CITY_MARKER                   //City markers
		DET_VEHICLE                       //Vehicle
		DET_POLYGON_NAME                  //Name of polygons
		DET_OFF_ROAD_ROUTE                //Connection line between end of a route and an off-road destination
		DET_TTI_ARROW                     //Direction arrow for TTI messages
		DET_POI_NAME                      //Points Of Interest with a label
		DET_RASTER_MAP                    //Raster maps
		DET_BREAD_CRUMB_TRAIL             //Line that connects bread crumbs (past positions)
		DET_EDGE_HIGHLIGHTING             //Draw highlighted edges that were selected by MAP_POINT_QUERY0 - MAP_POINT_QUERY4.
		DET_DIRECTION_ARROW               //Draw arrows that indicate driving or walking direction.
		DET_CITY_BUILDINGS                //Render city buildings.
		DET_FPS_DISPLAY                   //Measure and display frames per second.
		DET_CROSSHAIR                     //Display cross-hair.
		DET_DEVDROP_BANNER                //Enables drawing of a banner. The banner indicates that the current version is a developer's version. The banner is rendered across the display.
		DET_FRAME_AROUND_MAP 			   //a frame is rendered around the map.
		DET_CORONA                        //a corona is drawn around the earth.
		DET_WATEREFFECT                   //Demo effect for water.
		DET_TREES                         //Demo effect for trees.
		DET_RAIN                          //Demo effect for rain.
		DET_CITYMODEL_ROUTE_TRANSPARENCY  //Render buildings transparently around route.
		DET_ROUTE_DESTINATION             //Render destination POIs (e.g. destination flags).
		DET_RANGE_DISPLAY                 //Display range display.
		DET_POI_BRANDS                    //Display branded POIs.
		DET_WEATHER_MARKER                //DrawingElementType_DET_WEATHER_MARKER
		DET_WEATHER_OVERLAY               //Weather map overlay
		DET_WAYPOINT_ROUTE
		DET_WAYPOINT_ROUTE_MARKER
		DET_STENCIL		
	}

	enumeration PanAction extends BasicEnum { //Base 0x0100
		PAN_START		= 256
		PAN_TO			= 257
		PAN_END			= 258
	}
	
	enumeration Visibility extends BasicEnum { //Base 0x0040
		VISIBLE			= 67
		INVISIBLE		= 68
		FROZEN			= 69
	}

	enumeration Level extends BasicEnum { //Base 0x0050
		LEVEL_1			= 80
		LEVEL_2			= 81
		LEVEL_3			= 82
		LEVEL_4			= 83
		LEVEL_5			= 84
	}

	enumeration HeadingType extends BasicEnum  { //Base 0x0130
		CONSTANT_ANGLE		= 112
		TRACK_UP			= 113
		TOWARDS_TARGET		= 114
	} 

	enumeration MapTheme extends BasicEnum {	
		THEME_1	= 96
		THEME_2 = 97
		THEME_3 = 98
		THEME_BMW_CLASSIC_DAY
		THEME_BMW_CLASSIC_NIGHT
		THEME_BMW_CLASSIC_TRAFFIC_DAY
		THEME_BMW_CLASSIC_TRAFFIC_NIGHT
		THEME_BMW_ALTERNATIVE_DAY
		THEME_BMW_ALTERNATIVE_NIGHT
		THEME_BMW_ALTERNATIVE_TRAFFIC_DAY
		THEME_BMW_ALTERNATIVE_TRAFFIC_NIGHT
		THEME_BMW_GUIDING

		THEME_MINI_CLASSIC_DAY
		THEME_MINI_CLASSIC_NIGHT
		THEME_MINI_CLASSIC_TRAFFIC_DAY
		THEME_MINI_CLASSIC_TRAFFIC_NIGHT
		THEME_MINI_ALTERNATIVE_DAY
		THEME_MINI_ALTERNATIVE_NIGHT
		THEME_MINI_ALTERNATIVE_TRAFFIC_DAY
		THEME_MINI_ALTERNATIVE_TRAFFIC_NIGHT
		THEME_MINI_GUIDING

		THEME_I_CLASSIC_DAY
		THEME_I_CLASSIC_NIGHT
		THEME_I_CLASSIC_TRAFFIC_DAY
		THEME_I_CLASSIC_TRAFFIC_NIGHT
		THEME_I_ALTERNATIVE_DAY
		THEME_I_ALTERNATIVE_NIGHT
		THEME_I_ALTERNATIVE_TRAFFIC_DAY
		THEME_I_ALTERNATIVE_TRAFFIC_NIGHT
		THEME_I_GUIDING						
	}

	<**
		@description : struct generated for DBus argument CreateMapViewInstance_mapViewSize
	**>
	struct Dimension {
		UInt16 horizontalSize
		UInt16 verticalSize
	}

	map MapObjectVisibility {
		MapObject to Boolean
	}

	enumeration MapScaleUnit extends BasicEnum { //Base 0x0030
		METER		= 50
		MILE		= 51
		KM			= 52
		YARD		= 53
		FOOT		= 54
	}

	enumeration MapScaleType extends BasicEnum { //Base 0x0040
		MIN			= 64
		MAX			= 65
		MID			= 66
	}

	enumeration SelectableMapType extends BasicEnum {
        MET_POI = 2                            //POI.
        MET_POLYGON = 3                        //Polygons.
        MET_EDGE = 4                           //All edges except roads. E.g. railways rivers ferries.
        MET_ROAD = 5                           //Road edges.
        MET_ROAD_ICON = 6                      //Road icons.
        MET_TTI_ICON = 7                       //TTI icons.
        MET_TTI_EDGE = 8                       //TTI edge [Not yet supported].
        MET_CITY_MARKER = 9                    //City names and city markers.
        MET_ROUTE = 10                         //Tours.
        MET_TREKKING_ROUTE = 11                //Trekking tours.
        MET_POSITION = 12                      //Position.
        MET_LANDMARK = 13                      //Landmarks.
        MET_DESTINATION = 14                   //Destinations.
        MET_FAVORITE = 15                      //Favorites.
        MET_PICTURE = 16                       //Picture.
        MET_GENERIC_MARKER  = 17                //Generic markers like weather markers.
		
		CUSTOM_ELEMENT		= 288 //Base 0x0120
		CURRENT_POSITION	= 289
		WAYPOINT			= 290
		POI					= 291
		TRAFFIC_INCIDENT	= 292	
		ROUTE				= 293
		GEOCOORDINATES		= 294
	}

	<**
		@description : struct generated for DBus argument GetScaleList_scaleList
	**>
	struct MapScale {
		UInt16 scaleId
		UInt16 scaleValue
		MapScaleUnit unit
		UInt32 millimetersPerPixel
	}


	<**
		@description : struct generated for DBus argument SetMapViewSaveArea_saveArea
	**>
	struct MapViewArea {
		Double left
		Double right
		Double top
		Double bottom
	}

	<**
		@description : struct generated for DBus argument SetMapViewPan_pixelCoordinates
	**>
	struct Pixel {
		UInt16 x
		UInt16 y
	}


	<**
		@description : struct generated for DBus argument GetDisplayedRoutes_displayedRoutes
	**>
	struct DisplayedRoute {
		Handle	routeHandle
		Boolean highlighted
	}



	<**
		@description : struct generated for DBus argument DisplayCustomElements_customElementsElem4
	**>
	struct AnchorPoint {
		Int16 x
		Int16 y
	}

	<**
		@description : struct generated for DBus argument DisplayCustomElements_customElements
	**>
	struct CustomElement {
		String name
		String iconUri
		Coordinate2D coordinate
		AnchorPoint elem4
	}


	map tCustomElementDict {
		Handle to CustomElement
	}

	<**
		@description : struct generated for DBus argument SelectElementsOnMap_selectedElements
	**>
	struct SelectedMapElement {
		SelectableMapType type
		Coordinate2D position
		ElementValue value
	}

	union ElementValue {
		Int32 trafficIncident
		Handle handle
		CustomElement element
	}

	<**
		@description : getVersion = This method returns the API version implemented by the server application
	**>
	method getVersion {
		out {
			Version ^version
		}
	}

	<**
		@description : createMapViewInstance = This method creates a new map instance
	**>
	method createMapViewInstance {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle
			
			Dimension mapViewSize

			<**
				@description : mapViewType = enum(INVALID,MAIN_MAP,SPLIT_SCREEN, ... )
			**>
			MapViewType mapViewType
		}
		out {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
	}

	<**
		@description : releaseMapViewInstance = This method releases (i.e. destroys) a given map instance. Only invisible map instances can be released
	**>
	method releaseMapViewInstance {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
	}

	<**
		@description : getMapViewType = This method returns the map type of a map instance as it was set using CreateMapViewInstance
	**>
	method getMapViewType {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {

			<**
				@description : mapViewType = enum(INVALID,MAIN_MAP,SPLIT_SCREEN, ... )
			**>
			MapViewType mapViewType
		}
	}

	<**
		@description : getSupportedMapViewTypes = This method retrieves the supported map view types
	**>
	method getSupportedMapViewTypes {
		out {
			MapViewType [] mapViewTypeList
		}
	}

	<**
		@description : setTargetPoint = This method sets the position of the point the camera is always aimed at
	**>
	method setTargetPoint {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
			
			Coordinate3D targetPoint
		}
	}

	<**
		@description : getTargetPoint = This method retrieves the target point position
	**>
	method getTargetPoint {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {
			Coordinate3D targetPoint
		}
	}

	<**
		@description : setFollowCarMode = This method sets the FollowCar mode
	**>
	method setFollowCarMode {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : followCarMode = flag. If true, the current car position is interpreted as position of the point the camera must look at
			**>
			Boolean followCarMode
		}
	}

	<**
		@description : getFollowCarMode = This method returns the current FollowCar-mode
	**>
	method getFollowCarMode {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {

			<**
				@description : followCarMode = flag. If true, the current car position is interpreted as position of the point the camera must look at
			**>
			Boolean followCarMode
		}
	}

	<**
		@description : followCarModeChanged = This signal is emitted when the follow-car-mode changes
	**>
	broadcast followCarModeChanged {
		out {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : followCarMode = If true, the current car position is interpreted as position of the point the camera must look at
			**>
			Boolean followCarMode
		}
	}

	<**
		@description : setCameraPosition = This method sets the coordinates of the point at which the camera must be positioned
		Note: the camera heading will be automatically set in such a way, that the camera is aimed at the view point
	**>
	method setCameraPosition {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
			
			Coordinate3D position
		}
	}

	<**
		@description : getCameraPosition = This method returns the coordinates of the point at which the camera is positioned
	**>
	method getCameraPosition {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {
			Coordinate3D position
		}
	}

	<**
		@description : cameraPositionChanged = This signal is emitted when the position of the camera changes
	**>
	broadcast cameraPositionChanged {
		out {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : followCarMode = If true, the current car position is interpreted as position of the point the camera must look at
			**>
			Coordinate3D targetPoint
		}
	}

	<**
		@description : setCameraHeadingAngle = This method sets the map view heading angle
		Note: the camera position will be automatically set in such a way, that it looks at the currently selected target point
	**>
	method setCameraHeadingAngle {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : heading = heading angle in degrees. Range [0:360]
			**>
			Int32 heading
		}
	}

	<**
		@description : setCameraHeadingToTarget = This method sets the camera heading in such a way, that the camera always looks at a given target
	**>
	method setCameraHeadingToTarget {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
			
			Coordinate2D target
		}
	}

	<**
		@description : setCameraHeadingTrackUp = This method sets the camera heading in such a way, that the camera always looks in the direction in which the car is moving
	**>
	method setCameraHeadingTrackUp {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
	}

	<**
		@description : getCameraHeading = This method returns the current camera heading
	**>
	method getCameraHeading {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {

			<**
				@description : headingType = enum(INVALID,CONSTANT_ANGLE,TRACK_UP,TOWARDS_TARGET, ... )
			**>
			HeadingType headingType

			<**
				@description : headingAngle = heading angle in degrees measured from the North axis clockwise. Range[0:360]
			**>
			Int32 headingAngle
			
			Coordinate2D target
		}
	}
	
	<**
		@description : CameraHeadingChanged = This signal is emitted when the heading angle of the camera changes
	**>
	broadcast CameraHeadingChanged {
		out {
		
			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
			
			<**
				@description : headingType = enum(INVALID,CONSTANT_ANGLE,TRACK_UP,TOWARDS_TARGET, ... )
			**>
			HeadingType headingType
			
			<**
				@description : headingAngle = heading angle in degrees. Range [0:360]
				The angle in degrees between projection on the ground plane of the line through the center of the screen and the top-centre of the screen, and the North direction
				0 degrees means that the map view is oriented such that North is at the top of the screen
				Degrees are measured clockwise such that 90 degrees correspond to the East direction
			**>
			Int32 headingAngle
		}
	}

	<**
		@description : setCameraTiltAngle = This method sets the camera tilt angle
	**>
	method setCameraTiltAngle {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : tilt = tilt angle in degrees. Range [-180:180]
			**>
			Int32 tilt
		}
	}

	<**
		@description : getCameraTiltAngle = This method returns the camera tilt angle
	**>
	method getCameraTiltAngle {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {

			<**
				@description : tilt = tilt angle in degrees. Range [-180:180]
			**>
			Int32 tilt
		}
	}

	<**
		@description : cameraTiltAngleChanged = This signal is emitted when the camera tilt angle changes
	**>
	broadcast cameraTiltAngleChanged {
		out {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : tilt = tilt angle in degrees. Range [-180:180]
			**>
			Int32 tilt
		}
	}


	<**
		@description : setCameraRollAngle = This method sets the camera roll angle
	**>
	method setCameraRollAngle {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : roll = roll angle in degrees. Range [-180:180]
			**>
			Int32 roll
		}
	}

	<**
		@description : getCameraRollAngle = This method returns the camera roll angle
	**>
	method getCameraRollAngle {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {

			<**
				@description : roll = roll angle in degrees. Range [-180:180]
			**>
			Int32 roll
		}
	}

	<**
		@description : setCameraDistanceFromTargetPoint = This method sets the mode and the camera distance from the target point
	**>
	method setCameraDistanceFromTargetPoint {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : distance = distance from the view point in meters
			**>
			UInt32 distance
		}
	}

	<**
		@description : getCameraDistanceFromTargetPoint = This method gets the mode and the camera distance from the target point
	**>
	method getCameraDistanceFromTargetPoint {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {

			<**
				@description : distance = distance from the view point in meters
			**>
			UInt32 distance
		}
	}

	<**
		@description : cameraDistanceFromTargetPointChanged = This signal is emitted when the camera distance from the target point changes
	**>
	broadcast cameraDistanceFromTargetPointChanged {
		out {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : distance = distance from the view point in meters
			**>
			UInt32 distance
		}
	}

	<**
		@description : setMapViewScaleMode = This method sets the scaling mode.
	**>
	method setMapViewScaleMode {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : scaleMode = enum(AUTOMATIC,MANUAL,HYBRID)
			**>
			MapScaleMode scaleMode
		}
	}

	<**
		@description : getMapViewScaleMode = This method gets the scaling mode.
	**>
	method getMapViewScaleMode {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {

			<**
				@description : scaleMode = enum(AUTOMATIC,MANUAL,HYBRID)
			**>
			MapScaleMode scaleMode
		}
	}

	<**
		@description : mapViewScaleChanged = This signal is emitted when the mapview scale changes
	**>
	broadcast mapViewScaleChanged {
		out {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : scaleID = scale identifier. Range[0:256]
			**>
			UInt8 scaleID

			<**
				@description : isMinMax = enum(INVALID,MIN,MAX,MID, ... )
			**>
			MapScaleType isMinMax
		}
	}

	<**
		@description : getSupportedMapViewScaleModes = This method gets the supported scaling modes.
	**>
	method getSupportedMapViewScaleModes {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {
			MapScaleMode [] scaleModeList
		}
	}

	<**
		@description : addMapViewScaleChangedListener = This method adds a listener which is notified when map view scale changes.
	**>
	method addMapViewScaleChangedListener {
	}

	<**
		@description : removeMapViewScaleChangedListener = This method removes a listener which is notified when map view scale changes.
	**>
	method removeMapViewScaleChangedListener {
	}

	<**
		@description : setCameraHeight = This method sets the camera height
	**>
	method setCameraHeight {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : height = height from the ground in meters
			**>
			UInt32 height
		}
	}

	<**
		@description : getCameraHeight = This method gets the camera height
	**>
	method getCameraHeight {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {

			<**
				@description : height = height from the ground in meters
			**>
			UInt32 height
		}
	}

	<**
		@description : setMapViewPerspective = This method sets the map perspective
	**>
	method setMapViewPerspective {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : perspective = enum(INVALID,2D,3D, ... )
			**>
			MapPerspective perspective
		}
	}

	<**
		@description : getMapViewPerspective = This method returns the current map perspective
	**>
	method getMapViewPerspective {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {

			<**
				@description : perspective = enum(INVALID,2D,3D, ... )
			**>
			MapPerspective perspective
		}
	}
	
	<**
		@description : MapViewPerspectiveChanged = This signal is emitted when the map perspective chnages
	**>
	broadcast MapViewPerspectiveChanged {
		out {
		
			<**
				@description : Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
			
			<**
				@description : perspective = enum(INVALID,2D,3D, ... )</line>
			**>
			MapPerspective perspective
		}
	}

	<**
		@description : getSupportedMapViewPerspectives = This method retrieves the supported mapview perspectives
	**>
	method getSupportedMapViewPerspectives {
		out {
			MapPerspective[] perspectiveList
		}
	}

	<**
		@description : setMapViewObjectVisibility = This method specifies the type of objects to show on the map.
	**>
	method setMapViewObjectVisibility {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
			
			MapObjectVisibility objectVisibilityList
		}
	}

	<**
		@description : getMapViewObjectVisibility = This method gets the type of objects shown on the map.
	**>
	method getMapViewObjectVisibility {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {
			MapObjectVisibility objectVisibilityList
		}
	}

	<**
		@description : mapViewObjectVisibilityChanged = This signal is emitted when the type of objects shown on the map changes
	**>
	broadcast mapViewObjectVisibilityChanged {
		out {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : objectVisibilityList = if true the objects are shown else they are not shown
			**>
			MapObjectVisibility objectVisibilityList
		}
	}

	<**
		@description : getSupportedMapViewObjectVisibilities = This method gets the supported object visibilities.
	**>
	method getSupportedMapViewObjectVisibilities {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {
			MapObject [] objectVisibilityList
		}
	}

	<**
		@description : getScaleList = This method returns a list of supported map scales
	**>
	method getScaleList {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {
			MapScale[] scaleList
		}
	}

	<**
		@description : setMapViewScale = This method sets the map scale by specifying a ScaleID
	**>
	method setMapViewScale {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : scaleID = scale identifier. Range[0:256]
			**>
			UInt16 scaleID
		}
	}

	<**
		@description : setMapViewScaleByDelta = This method sets the map scale by specifying a delta value with respect to the currently set ScaleID
	**>
	method setMapViewScaleByDelta {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : scaleDelta = This parameter can have either positive or negative values. '0' means no change. Positive values indicate larger scales
			**>
			Int16 scaleDelta
		}
	}

	<**
		@description : setMapViewScaleByMetersPerPixel = This method sets the map scale by specifying the number of meters that a pixel represents
	**>
	method setMapViewScaleByMetersPerPixel {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : metersPerPixel = meters per pixel
			**>
			Double metersPerPixel
		}
	}

	<**
		@description : getMapViewScale = This method returns the currently used map scale
	**>
	method getMapViewScale {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {

			<**
				@description : scaleID = scale identifier. Range[0:256]
			**>
			UInt8 scaleID

			<**
				@description : isMinMax = enum(INVALID,MIN,MAX,MID, ... )
			**>
			MapScaleType isMinMax
		}
	}

	<**
		@description : setMapViewBoundingBox = This method sets the map bounding box
	**>
	method setMapViewBoundingBox {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
			
			Rectangle boundingBox
		}
	}

	<**
		@description : getMapViewBoundingBox = This method returns the bounding box of a given map instance
	**>
	method getMapViewBoundingBox {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {
			Rectangle boundingBox
		}
	}

	<**
		@description : mapViewBoundingBoxChanged = This signal is emitted when the bounding box of a map instance changes
	**>
	broadcast mapViewBoundingBoxChanged {
		out {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			Rectangle boundingBox
		}
	}

	<**
		@description : setMapViewSaveArea = This methods defines the area that the HMI guarantees not to 
		cover with other windows or user interface elements
	**>
	method setMapViewSaveArea {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
			
			MapViewArea saveArea
		}
	}

	<**
		@description : getMapViewSaveArea = This methods defines the area that the HMI guarantees not to 
		cover with other windows or user interface elements
	**>
	method getMapViewSaveArea {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {
			MapViewArea saveArea
		}
	}

	<**
		@description : mapViewSaveAreaChanged = This signal is emitted when the area that the HMI guarantees not to cover with other windows or user interface elements chnages
	**>
	broadcast mapViewSaveAreaChanged {
		out {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			MapViewArea saveArea
		}
	}

	<**
		@description : setMapViewPan = This method pans a given map instance
	**>
	method setMapViewPan {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : panningAction = enum(PAN_START,PAN_TO,PAN_END)
			**>
			PanAction panningAction
			
			Pixel [] pixelCoordinates
		}
	}

	<**
		@description : getMapViewPan
	**>
	method getMapViewPan {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : valueToReturn = enum(PAN_START,PAN_TO,PAN_END)
			**>
			PanAction  valueToReturn
		}
		out {
			
			Pixel [] pixelCoordinates
		}
	}

	<**
		@description : setMapViewRotation = This method rotates the map
	**>
	method setMapViewRotation {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : rotationAngle = rotation angle in degrees measured from the North axis clockwise. Range[0:360]
			**>
			Int32 rotationAngle

			<**
				@description : rotationAnglePerSecond = partial rotation for each second
				The value can be set implement a smooth rotation
				If rotationAnglePerSecond = rotationAngle it means that the rotation must be instantaneous
			**>
			Int32 rotationAnglePerSecond
		}
	}

	<**
		@description : getMapViewRotation = This method is particularly interesting for debugging purposes
	**>
	method getMapViewRotation {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {

			<**
				@description : rotationAngle = rotation angle in degrees measured from the North axis clockwise. Range[0:360]
			**>
			Int32 rotationAngle

			<**
				@description : rotationAnglePerFrame = partial rotation for each map frame in degrees
			**>
			Int32 rotationAnglePerFrame
		}
	}

	<**
		@description : setMapViewVisibilityMode = This method sets the current visibility mode
	**>
	method setMapViewVisibilityMode {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : visibilityMode = enum(INVALID,VISIBLE,INVISIBLE,FROZEN, ... )
			**>
			Visibility visibilityMode
		}
	}

	<**
		@description : getMapViewVisibilityMode = This method returns the current visibility mode
	**>
	method getMapViewVisibilityMode {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {

			<**
				@description : visibilityMode = enum(INVALID,VISIBLE,INVISIBLE,FROZEN, ... )
			**>
			Visibility visibilityMode
		}
	}

	<**
		@description : mapViewVisibilityChanged = This signal is emitted when the MapView visibility changes
	**>
	broadcast mapViewVisibilityChanged {
		out {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : visibilityMode = enum(INVALID,VISIBLE,INVISIBLE,FROZEN, ... )
			**>
			Visibility visibilityMode
		}
	}

	<**
		@description : getSupportedMapViewVisibilityModes = This method retrieves the supported mapview visibility modes
	**>
	method getSupportedMapViewVisibilityModes {
		out {
			Visibility [] visibilityModeList
		}
	}

	<**
		@description : setMapViewPerformanceLevel = This method sets the perfomance level of a given map instance
	**>
	method setMapViewPerformanceLevel {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
				Note: it can be used to set the MapView in application specific performance mode (e.g. low CPU-usage or low memory-usage)
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : performanceLevel = enum(INVALID,LEVEL1,LEVEL2,LEVEL3,LEVEL4,LEVEL5, ... )
			**>
			Level performanceLevel
		}
	}

	<**
		@description : getMapViewPerformanceLevel = This method returns the perfomance level of a given map instance
	**>
	method getMapViewPerformanceLevel {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {

			<**
				@description : performanceLevel = enum(INVALID,LEVEL1,LEVEL2,LEVEL3,LEVEL4,LEVEL5, ... )
			**>
			Level performanceLevel
		}
	}

	<**
		@description : mapViewPerformanceLevelChanged = This signal is emitted when the perfomance level of a map instance changes
	**>
	broadcast mapViewPerformanceLevelChanged {
		out {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : performanceLevel = enum(INVALID,LEVEL1,LEVEL2,LEVEL3,LEVEL4,LEVEL5, ... )
			**>
			Level performanceLevel
		}
	}

	<**
		@description : getSupportedMapViewPerformanceLevels = This method retrieves the supported perfomance levels
	**>
	method getSupportedMapViewPerformanceLevels {
		out {
			Level [] performanceLevelList
		}
	}

	<**
		@description : displayRoute = This method visualizes one of the calculated routes
	**>
	method displayRoute {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle routeHandle

			<**
				@description : highlighted = flag. TRUE means highligted,FALSE means not highlighted
			**>
			Boolean highlighted
		}
	}

	<**
		@description : hideRoute = This method hides one of the visible routes
	**>
	method hideRoute {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle routeHandle
		}
	}

	<**
		@description : displayedRoutes = This signal is emitted when the list of displayed routes change
	**>
	broadcast displayedRoutes {
		out {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
			DisplayedRoute [] displayedRoutes
		}
	}

	<**
		@description : getDisplayedRoutes = This method returns a list of displayed routes
	**>
	method getDisplayedRoutes {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {
			DisplayedRoute [] displayedRoutes
		}
	}

	<**
		@description : getPoiCategoriesVisible = Get the set of POI categories displayed on the map.
	**>
	method getPoiCategoriesVisible {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {
			CategoryID[] poiCategoryIds
		}
	}

	<**
		@description : setPoiCategoriesVisible = Add POI categories to the set of POI categories displayed on the map.
                   Any specified category that until now was displayed with scale limits is now displayed without limits.
	**>
	method setPoiCategoriesVisible {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
			
			CategoryID[] poiCategoryIds
		}
	}

	<**
		@description : setPoiCategoriesVisible = Add POI categories to the set of POI categories displayed on the map, where the POI's are only displayed in a specific range of scales.
                   Any specified category that until now was displayed without scale limits is now displayed with limits.
	**>
	method setPoiCategoriesVisibleWithinLimits {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
			
			CategoryID[] poiCategoryIds

			<**
				@description : minScaleID = minimun scale on which the POI categories are displayed
			**>
			UInt8 minScaleID

			<**
				@description : maxScaleID = maximum scale on which the POI categories are displayed
			**>
			UInt8 maxScaleID
		}
	}

	<**
		@description : setPoiCategoriesNotVisible = Remove POI categories from the set of POI categories displayed on the map.
	**>
	method setPoiCategoriesNotVisible {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
			
			CategoryID[] poiCategoryIds
		}
	}

	<**
		@description : poiCategoriesVisibilityChanged = This signal is emitted when the visibility of POI categories on a map instance changes
	**>
	broadcast poiCategoriesVisibilityChanged {
		out {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			CategoryID[] poiCategoryIds

			<**
				@description : visible = TRUE means that the POI categories are visible
			**>
			Boolean visible

			<**
				@description : minScaleID = minimun scale on which the POI categories are displayed
			**>
			UInt8 minScaleID

			<**
				@description : maxScaleID = maximum scale on which the POI categories are displayed
			**>
			UInt8 maxScaleID
		}
	}

	<**
		@description : setTrafficIncidentsVisibility = Set the visibility of Traffic Incidents on the map.
	**>
	method setTrafficIncidentsVisibility {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : visible = If true, Traffic Incidents are shown on the map, else they are not shown.
			**>
			Boolean visible
		}
	}

	<**
		@description : setMapViewTheme = This method configures the theme of a given map view instance
	**>
	method setMapViewTheme {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : mapViewTheme = enum(INVALID,THEME_1,THEME_2,THEME_3, ... )
			**>
			MapTheme mapViewTheme
		}
	}

	<**
		@description : getMapViewTheme = This method returns the current theme of a given map view instance
	**>
	method getMapViewTheme {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {

			<**
				@description : mapViewTheme = enum(INVALID,THEME_1,THEME_2,THEME_3, ... )
			**>
			MapTheme mapViewTheme
		}
	}

	<**
		@description : mapViewThemeChanged = This signal is emitted when the theme of a map view instance changes
	**>
	broadcast mapViewThemeChanged {
		out {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle

			<**
				@description : mapViewTheme = enum(INVALID,THEME_1,THEME_2,THEME_3, ... )
			**>
			MapTheme mapViewTheme
		}
	}

	<**
		@description : getSupportedMapViewThemes = This method retrieves the supported mapview themes
	**>
	method getSupportedMapViewThemes {
		out {
			MapTheme [] mapViewThemeList
		}
	}

	<**
		@description : convertPixelCoordsToGeoCoords = This method converts pixel coordinates to geographical coordinates
	**>
	method convertPixelCoordsToGeoCoords {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
			
			Pixel [] pixelCoordinates
		}
		out {			
			Coordinate2D [] geoCoordinates
		}
	}

	<**
		@description : convertGeoCoordsToPixelCoords = This method converts geographical coordinates into pixel coordinates
	**>
	method convertGeoCoordsToPixelCoords {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
			

			Coordinate2D [] geoCoordinates
		}
		out {
			
			Pixel [] pixelCoordinates
		}
	}

	<**
		@description : displayCustomElements = This method visualizes a set of custom elements on the map
	**>
	method displayCustomElements {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
			CustomElement [] customElements
		}
		out {
			Handle[] customElemenHandles
		}
	}

	<**
		@description : hideCustomElements = This method hides a set of custom elements which were visualized by DisplayCustomElements
	**>
	method hideCustomElements {
		in {

			<**
				@description : sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle sessionHandle

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
			
			Handle [] customElemenHandles
		}
	}

	<**
		@description : getDisplayedCustomElements = This method retrieves the visualized custom elements on the map
	**>
	method getDisplayedCustomElements {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
		}
		out {
			tCustomElementDict customElements
		}
	}

	<**
		@description : selectElementsOnMap = This method selects elements on the map view which are at the position specified by user input
	**>
	method selectElementsOnMap {
		in {

			<**
				@description : mapViewInstanceHandle = Map instance handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle mapViewInstanceHandle
			
			Pixel pixelCoordinate
			
			SelectableMapType [] selectableTypes

			<**
				@description : maxNumberOfSelectedElements = maximum number of selected elements to return. If 0, all possible elements which can be selected will be returned
			**>
			UInt16 maxNumberOfSelectedElements
		}
		out {
			SelectedMapElement [] selectedElements
		}
	}

}