/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 2.1.6.v20140519.
* Used org.franca.core 0.8.11.201401091023.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#ifndef ORG_GENIVI_NAVIGATION_POISERVICE_POI_Service_Types_H_
#define ORG_GENIVI_NAVIGATION_POISERVICE_POI_Service_Types_H_


#include <org/genivi/navigation/NavigationTypes.h>

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/InputStream.h>
#include <CommonAPI/OutputStream.h>
#include <CommonAPI/SerializableStruct.h>
#include <CommonAPI/SerializableVariant.h>
#include <CommonAPI/types.h>
#include <cstdint>
#include <memory>
#include <string>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace org {
namespace genivi {
namespace navigation {
namespace poiservice {

namespace POIServiceTypes {
    /**
     * Unique ID for a POI results
     */
    /**
     * Unique ID for a POI results
     */
    typedef uint32_t POI_ID;
    /**
     * Unique ID for a POI Categories
     */
    /**
     * Unique ID for a POI Categories
     */
    typedef uint32_t CategoryID;
    /**
     * Unique ID for a POI Icon Resource
     */
    /**
     * Unique ID for a POI Icon Resource
     */
    typedef uint32_t ResourceID;
    typedef uint32_t AttributeID;
    /**
     * Current state of the search
     */
    enum class SearchStatusState: int32_t {
        INVALID,
        NOT_STARTED,
        SEARCHING,
        FINISHED
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct SearchStatusStateComparator;
    /**
     * Type of Attribute
     */
    enum class AttributeType: int32_t {
        INTEGER,
        BOOLEAN,
        COORDINATE
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct AttributeTypeComparator;
    /**
     * Type of Operator
     */
    enum class OperatorType: int32_t {
        INVALID,
        MORE_THAN,
        LESS_THAN,
        EQUAL
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct OperatorTypeComparator;
    /**
     * Reason of update
     */
    enum class UpdateReason: int32_t {
        ADDED,
        REMOVED,
        ATTR_ADDED,
        ATTR_MODIFIED,
        ATTR_REMOVED
    };
    
    // Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct UpdateReasonComparator;
    /**
     * Different types of resources for icons
     */
    /**
     * Different types of resources for icons
     */
    typedef CommonAPI::Variant<std::vector<ResourceID>, std::string>  Icon;
    /**
     * Differtent type of media
     */
    /**
     * Differtent type of media
     */
    typedef CommonAPI::Variant<std::vector<ResourceID>, std::string>  Media;
    /**
     * values for attributes.
     */
    /**
     * values for attributes.
     */
    typedef CommonAPI::Variant<std::vector<int32_t>, std::vector<std::string>, std::vector<bool>, std::vector<NavigationTypes::Coordinate2D>>  AttributeValue;
    /**
     * 
     */
    /**
     * 
     */
    struct Details: CommonAPI::SerializableStruct {
        /**
         * list of parent categories unique id.
         */
         std::vector<CategoryID> parentsId;
        /**
         * visual icons set.
         */
         Icon icons;
        /**
         * name.
         */
         std::string name;
        /**
         * short category description (optional).
         */
         std::string shortDesc;
        /**
         * media associated (html web site, audio, video, ...) (optional).
         */
         Media media;
    
        Details() = default;
        Details(const std::vector<CategoryID>& parentsId, const Icon& icons, const std::string& name, const std::string& shortDesc, const Media& media);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeUInt32Type();typeOutputStream.endWriteVectorType();
            typeOutputStream.writeVariantType();
            typeOutputStream.writeStringType();
            typeOutputStream.writeStringType();
            typeOutputStream.writeVariantType();
        }
    };
    /**
     * 
     */
    /**
     * 
     */
    struct Operator: CommonAPI::SerializableStruct {
        /**
         * enum(INVALID,MORE_THAN,LESS_THAN,EQUAL, ....).
         */
         OperatorType type;
        /**
         * localized display name.
         */
         std::string name;
        /**
         * value to use if this comparator is selected.
         */
         AttributeValue value;
    
        Operator() = default;
        Operator(const OperatorType& type, const std::string& name, const AttributeValue& value);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeStringType();
            typeOutputStream.writeVariantType();
        }
    };
    /**
     * Describes an attribte which is associcated to an category. Use more than one
     *  operator to specify choice options i.e. differtent accpeted credid cards
     *  
    	used in categor details and update category
     */
    /**
     * Describes an attribte which is associcated to an category. Use more than one
     *  operator to specify choice options i.e. differtent accpeted credid cards
     *  
    	used in categor details and update category
     */
    struct CategoryAttribute: CommonAPI::SerializableStruct {
        /**
         * id of attribute .
         */
         AttributeID id;
        /**
         * localized display name.
         */
         std::string name;
        /**
         * enum(INVALID,STRING,INTEGER,COORDINATES ...).
         */
         AttributeType type;
        /**
         * 
         */
         std::vector<Operator> operators;
    
        CategoryAttribute() = default;
        CategoryAttribute(const AttributeID& id, const std::string& name, const AttributeType& type, const std::vector<Operator>& operators);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt32Type();
            typeOutputStream.writeStringType();
            typeOutputStream.writeInt32Type();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeStringType();typeOutputStream.writeVariantType();
            typeOutputStream.endWriteStructType();typeOutputStream.endWriteVectorType();
        }
    };
    /**
     * 
     */
    /**
     * 
     */
    struct CategorySortOption: CommonAPI::SerializableStruct {
        /**
         * enum(SORT_DEFAULT,SORT_BY_DISTANCE,SORT_BY_TIME,ATTRIBUTE_CUSTOM, ... ).
         */
         CategoryID id;
        /**
         * localized name to be displayed by application.
         */
         std::string name;
    
        CategorySortOption() = default;
        CategorySortOption(const CategoryID& id, const std::string& name);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt32Type();
            typeOutputStream.writeStringType();
        }
    };
    /**
     * 
     */
    /**
     * 
     */
    struct CAMCategory: CommonAPI::SerializableStruct {
        /**
         * struct(list of parents_id, icons, name, short_desc, media).
         */
         Details details;
        /**
         * array[struct(name, type, array[struct(operator_id, operator_name)])].
         */
         std::vector<CategoryAttribute> attributes;
        /**
         * array[struct(id, name)].
         */
         std::vector<CategorySortOption> sortOptions;
    
        CAMCategory() = default;
        CAMCategory(const Details& details, const std::vector<CategoryAttribute>& attributes, const std::vector<CategorySortOption>& sortOptions);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.beginWriteStructType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeUInt32Type();typeOutputStream.endWriteVectorType();
            typeOutputStream.writeVariantType();typeOutputStream.writeStringType();typeOutputStream.writeStringType();typeOutputStream.writeVariantType();
            typeOutputStream.endWriteStructType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt32Type();typeOutputStream.writeStringType();typeOutputStream.writeInt32Type();typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeStringType();typeOutputStream.writeVariantType();
            typeOutputStream.endWriteStructType();typeOutputStream.endWriteVectorType();
            
            typeOutputStream.endWriteStructType();typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt32Type();typeOutputStream.writeStringType();
            typeOutputStream.endWriteStructType();typeOutputStream.endWriteVectorType();
        }
    };
    /**
     * 
     */
    /**
     * 
     */
    struct CAMCategoryUpdate: CommonAPI::SerializableStruct {
        /**
         * enum(INVALID,ALL_CATEGORIES,AIRPORT,RESTAURANT,HOTEL,GAZ_STATION,CAR_PARK,
         *  ...). Note: A POI category is a unique ID. It could be a predefined category
         *  or a custom one defined by a POI plug-in
         */
         CategoryID id;
        /**
         * array[struct(name, type, array[struct(operator_id, operator_name)])].
         */
         std::vector<CategoryAttribute> attributes;
        /**
         * array[struct(id, name)].
         */
         std::vector<CategorySortOption> sortOptions;
    
        CAMCategoryUpdate() = default;
        CAMCategoryUpdate(const CategoryID& id, const std::vector<CategoryAttribute>& attributes, const std::vector<CategorySortOption>& sortOptions);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt32Type();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt32Type();typeOutputStream.writeStringType();typeOutputStream.writeInt32Type();typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeStringType();typeOutputStream.writeVariantType();
            typeOutputStream.endWriteStructType();typeOutputStream.endWriteVectorType();
            
            typeOutputStream.endWriteStructType();typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt32Type();typeOutputStream.writeStringType();
            typeOutputStream.endWriteStructType();typeOutputStream.endWriteVectorType();
        }
    };
    /**
     * Attribute associcated to an POI used in addPOI and POI Search Result(both CAM
     *  and Service)
     */
    /**
     * Attribute associcated to an POI used in addPOI and POI Search Result(both CAM
     *  and Service)
     */
    struct PoiAttribute: CommonAPI::SerializableStruct {
        /**
         * attribute unique id (see data model)
         */
         AttributeID id;
        /**
         * enum(INVALID,STRING,INTEGER,COORDINATES ...)
         */
         AttributeType type;
        /**
         * The value depends on the attribute specifications and type
         */
         AttributeValue value;
    
        PoiAttribute() = default;
        PoiAttribute(const AttributeID& id, const AttributeType& type, const AttributeValue& value);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt32Type();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeVariantType();
        }
    };
    /**
     * 
     */
    /**
     * 
     */
    struct CategoryAndRadius: CommonAPI::SerializableStruct {
        /**
         * enum(INVALID,ALL_CATEGORIES,AIRPORT,RESTAURANT,HOTEL,GAZ_STATION,CAR_PARK,
         *  ...). Note: A POI category is a unique ID. It could be a predefined category
         *  or a custom one defined by a POI plug-in
         */
         CategoryID id;
        /**
         * activation or search radius around the position (in 10 meters) for the
         *  category. If value is 0 (zero), the default radius (defined for a category) is
         *  applied.
         */
         uint32_t radius;
    
        CategoryAndRadius() = default;
        CategoryAndRadius(const CategoryID& id, const uint32_t& radius);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt32Type();
            typeOutputStream.writeUInt32Type();
        }
    };
    /**
     * 
     */
    /**
     * 
     */
    struct PoiDetails: CommonAPI::SerializableStruct {
        /**
         * POI id
         */
         POI_ID id;
        /**
         * POI name
         */
         std::string name;
        /**
         * POI location.
         */
         NavigationTypes::Coordinate3D location;
    
        PoiDetails() = default;
        PoiDetails(const POI_ID& id, const std::string& name, const NavigationTypes::Coordinate3D& location);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt32Type();
            typeOutputStream.writeStringType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeDoubleType();typeOutputStream.writeDoubleType();typeOutputStream.writeInt32Type();
            typeOutputStream.endWriteStructType();
        }
    };
    /**
     * 
     */
    /**
     * 
     */
    struct SearchResultDetails: CommonAPI::SerializableStruct {
        /**
         * struct(id,name,latitude,longitude,altitude).
         */
         PoiDetails details;
        /**
         * array[unique_id].
         */
         std::vector<CategoryID> categories;
        /**
         * array[struct(name,type,value)].
         */
         std::vector<PoiAttribute> attributes;
    
        SearchResultDetails() = default;
        SearchResultDetails(const PoiDetails& details, const std::vector<CategoryID>& categories, const std::vector<PoiAttribute>& attributes);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt32Type();typeOutputStream.writeStringType();typeOutputStream.beginWriteStructType();
            typeOutputStream.writeDoubleType();typeOutputStream.writeDoubleType();typeOutputStream.writeInt32Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteStructType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeUInt32Type();typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt32Type();typeOutputStream.writeInt32Type();typeOutputStream.writeVariantType();
            typeOutputStream.endWriteStructType();typeOutputStream.endWriteVectorType();
        }
    };
    /**
     * 
     */
    /**
     * 
     */
    struct SearchResult: CommonAPI::SerializableStruct {
        /**
         * POI id
         */
         POI_ID id;
        /**
         * distance in meters to poi from center of the search or from vehicle if search
         *  along
         */
         uint32_t distance;
        /**
         * enum(OFF_ROUTE,ON_ROUTE,INSIDE_CORRIDOR, ... )
         */
         uint16_t routeStatus;
        /**
         * List of attributes requested. It could be empty
         */
         std::vector<PoiAttribute> attributes;
    
        SearchResult() = default;
        SearchResult(const POI_ID& id, const uint32_t& distance, const uint16_t& routeStatus, const std::vector<PoiAttribute>& attributes);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt32Type();
            typeOutputStream.writeUInt32Type();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt32Type();typeOutputStream.writeInt32Type();typeOutputStream.writeVariantType();
            typeOutputStream.endWriteStructType();typeOutputStream.endWriteVectorType();
        }
    };
    /**
     * 
     */
    /**
     * 
     */
    struct PoiCAMDetails: CommonAPI::SerializableStruct {
        /**
         * POI unique id as known by the content access module. This id will be used by
         *  POI service to request POI details.
         */
         POI_ID sourceId;
        /**
         * POI name.
         */
         std::string name;
        /**
         * POI category unique id.
         */
         CategoryID category;
        /**
         * POI location.
         */
         NavigationTypes::Coordinate3D location;
        /**
         * distance in meters to poi from center of the search.
         */
         uint16_t distance;
        /**
         * List of attributes requested. It could be empty.
         */
         std::vector<PoiAttribute> attributes;
    
        PoiCAMDetails() = default;
        PoiCAMDetails(const POI_ID& sourceId, const std::string& name, const CategoryID& category, const NavigationTypes::Coordinate3D& location, const uint16_t& distance, const std::vector<PoiAttribute>& attributes);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt32Type();
            typeOutputStream.writeStringType();
            typeOutputStream.writeUInt32Type();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeDoubleType();typeOutputStream.writeDoubleType();typeOutputStream.writeInt32Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.writeUInt16Type();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt32Type();typeOutputStream.writeInt32Type();typeOutputStream.writeVariantType();
            typeOutputStream.endWriteStructType();typeOutputStream.endWriteVectorType();
        }
    };
    /**
     * used in setAttrbutes and CAM startPOISearch
     */
    /**
     * used in setAttrbutes and CAM startPOISearch
     */
    struct AttributeDetails: CommonAPI::SerializableStruct {
        /**
         * id of attribute .
         */
         AttributeID id;
        /**
         * enum(INVALID,ALL_CATEGORIES,AIRPORT,RESTAURANT,HOTEL,GAZ_STATION,CAR_PARK,
         *  ...). Note: A POI category is a unique ID. It could be a predefined category
         *  or a custom one defined by a POI plug-in
         */
         CategoryID categoryId;
        /**
         * enum(INVALID,STRING,INTEGER,COORDINATES ...).
         */
         AttributeType type;
        /**
         * value or partial value. The value depends on the attribute specifications and
         *  type.
         */
         AttributeValue value;
        /**
         * enum(INVALID,MORE_THAN,LESS_THAN,EQUAL, ....).
         */
         OperatorType oper;
        /**
         * true if the attribute is mandatory for the search and false for optional.
         */
         bool mandatory;
    
        AttributeDetails() = default;
        AttributeDetails(const AttributeID& id, const CategoryID& categoryId, const AttributeType& type, const AttributeValue& value, const OperatorType& oper, const bool& mandatory);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt32Type();
            typeOutputStream.writeUInt32Type();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeVariantType();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeBoolType();
        }
    };
    /**
     * Detailed descripton of a category
     */
    /**
     * Detailed descripton of a category
     */
    struct CategoryDetails: CommonAPI::SerializableStruct {
        /**
         * Category unique id.
         */
         CategoryID uniqueId;
        /**
         * list of parent categories unique id.
         */
         std::vector<CategoryID> parentsId;
        /**
         * visual icons set.
         */
         Icon icons;
        /**
         * name.
         */
         std::string name;
        /**
         * true if the category is a pre-defined one (top level), false for customized
         *  categories created by plug-in.
         */
         bool topLevel;
        /**
         * short category description (optional).
         */
         std::string description;
        /**
         * media associated (html web site, audio, video, ...) (optional).
         */
         Media media;
    
        CategoryDetails() = default;
        CategoryDetails(const CategoryID& uniqueId, const std::vector<CategoryID>& parentsId, const Icon& icons, const std::string& name, const bool& topLevel, const std::string& description, const Media& media);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt32Type();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeUInt32Type();typeOutputStream.endWriteVectorType();
            typeOutputStream.writeVariantType();
            typeOutputStream.writeStringType();
            typeOutputStream.writeBoolType();
            typeOutputStream.writeStringType();
            typeOutputStream.writeVariantType();
        }
    };
    /**
     * Detailed description of a category including attributes and sort options
     */
    /**
     * Detailed description of a category including attributes and sort options
     */
    struct Category: CommonAPI::SerializableStruct {
        /**
         * struct(unique_id, list of parents_id, icons, name, top_level, short_desc,
         *  media).
         */
         CategoryDetails details;
        /**
         * array[struct(name, type, array[struct(operator_id, operator_name)].
         */
         std::vector<CategoryAttribute> attributes;
        /**
         * array[struct(id, name)].
         */
         std::vector<CategorySortOption> sortOptions;
    
        Category() = default;
        Category(const CategoryDetails& details, const std::vector<CategoryAttribute>& attributes, const std::vector<CategorySortOption>& sortOptions);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt32Type();typeOutputStream.beginWriteVectorType();
            typeOutputStream.writeUInt32Type();typeOutputStream.endWriteVectorType();
            typeOutputStream.writeVariantType();typeOutputStream.writeStringType();typeOutputStream.writeBoolType();typeOutputStream.writeStringType();typeOutputStream.writeVariantType();
            typeOutputStream.endWriteStructType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt32Type();typeOutputStream.writeStringType();typeOutputStream.writeInt32Type();typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeInt32Type();typeOutputStream.writeStringType();typeOutputStream.writeVariantType();
            typeOutputStream.endWriteStructType();typeOutputStream.endWriteVectorType();
            
            typeOutputStream.endWriteStructType();typeOutputStream.endWriteVectorType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt32Type();typeOutputStream.writeStringType();
            typeOutputStream.endWriteStructType();typeOutputStream.endWriteVectorType();
        }
    };
    /**
     * Pair of catgory and description of level
     */
    /**
     * Pair of catgory and description of level
     */
    struct CategoryAndLevel: CommonAPI::SerializableStruct {
        /**
         * Category unique id.
         */
         CategoryID uniqueId;
        /**
         * true if the category is a pre-defined one (top level), false for customized
         *  categories created by plug-in.
         */
         bool topLevel;
    
        CategoryAndLevel() = default;
        CategoryAndLevel(const CategoryID& uniqueId, const bool& topLevel);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt32Type();
            typeOutputStream.writeBoolType();
        }
    };
    /**
     * pair of category and name
     */
    /**
     * pair of category and name
     */
    struct CategoryAndName: CommonAPI::SerializableStruct {
        /**
         * Category unique id.
         */
         CategoryID uniqueId;
        /**
         * name.
         */
         std::string name;
        /**
         * true if the category is a pre-defined one (top level), false for customized
         *  categories created by plug-in.
         */
         bool topLevel;
    
        CategoryAndName() = default;
        CategoryAndName(const CategoryID& uniqueId, const std::string& name, const bool& topLevel);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt32Type();
            typeOutputStream.writeStringType();
            typeOutputStream.writeBoolType();
        }
    };
    /**
     * pair of category and reson for update
     */
    /**
     * pair of category and reson for update
     */
    struct CategoryAndReason: CommonAPI::SerializableStruct {
        /**
         * Category unique id.
         */
         CategoryID unique_id;
        /**
         * enum(ADDED,REMOVED,ATTR_ADDED,ATTR_MODIFIED,ATTR_REMOVED, ... ) .
         */
         uint16_t reason;
    
        CategoryAndReason() = default;
        CategoryAndReason(const CategoryID& unique_id, const uint16_t& reason);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt32Type();
            typeOutputStream.writeUInt16Type();
        }
    };
    /**
     * pair of category and the this category is available
     */
    /**
     * pair of category and the this category is available
     */
    struct CategoryAndStatus: CommonAPI::SerializableStruct {
        /**
         * Category unique id.
         */
         CategoryID uniqueId;
        /**
         * true if the category is available .
         */
         bool status;
    
        CategoryAndStatus() = default;
        CategoryAndStatus(const CategoryID& uniqueId, const bool& status);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeUInt32Type();
            typeOutputStream.writeBoolType();
        }
    };
    /**
     * 
     */
    /**
     * 
     */
    struct PoiAddedDetails: CommonAPI::SerializableStruct {
        /**
         * POI name
         */
         std::string name;
        /**
         * POI location.
         */
         NavigationTypes::Coordinate3D location;
        /**
         * array[struct(name,type,value)].
         */
         std::vector<PoiAttribute> attributes;
    
        PoiAddedDetails() = default;
        PoiAddedDetails(const std::string& name, const NavigationTypes::Coordinate3D& location, const std::vector<PoiAttribute>& attributes);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeStringType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeDoubleType();typeOutputStream.writeDoubleType();typeOutputStream.writeInt32Type();
            typeOutputStream.endWriteStructType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeUInt32Type();typeOutputStream.writeInt32Type();typeOutputStream.writeVariantType();
            typeOutputStream.endWriteStructType();typeOutputStream.endWriteVectorType();
        }
    };
    struct Locales: CommonAPI::SerializableStruct {
        /**
         * the language used. ISO 639‐3 language code (lower case)
         */
         std::string languageCode;
        /**
         * the country specific variant for the language used. ISO 3166‐1 alpha 3 country
         *  code (upper case)
         */
         std::string countryCode;
        /**
         * the script specific variant for the language used. ISO 15924 alpha 4 script
         *  code (upper case)
         */
         std::string scriptCode;
    
        Locales() = default;
        Locales(const std::string& languageCode, const std::string& countryCode, const std::string& scriptCode);
    
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeStringType();
            typeOutputStream.writeStringType();
            typeOutputStream.writeStringType();
        }
    };

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, SearchStatusState& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const SearchStatusState& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct SearchStatusStateComparator {
    inline bool operator()(const SearchStatusState& lhs, const SearchStatusState& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, AttributeType& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const AttributeType& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct AttributeTypeComparator {
    inline bool operator()(const AttributeType& lhs, const AttributeType& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, OperatorType& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const OperatorType& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct OperatorTypeComparator {
    inline bool operator()(const OperatorType& lhs, const OperatorType& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, UpdateReason& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const UpdateReason& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct UpdateReasonComparator {
    inline bool operator()(const UpdateReason& lhs, const UpdateReason& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

bool operator==(const Details& lhs, const Details& rhs);
inline bool operator!=(const Details& lhs, const Details& rhs) {
    return !(lhs == rhs);
}
bool operator==(const Operator& lhs, const Operator& rhs);
inline bool operator!=(const Operator& lhs, const Operator& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CategoryAttribute& lhs, const CategoryAttribute& rhs);
inline bool operator!=(const CategoryAttribute& lhs, const CategoryAttribute& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CategorySortOption& lhs, const CategorySortOption& rhs);
inline bool operator!=(const CategorySortOption& lhs, const CategorySortOption& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CAMCategory& lhs, const CAMCategory& rhs);
inline bool operator!=(const CAMCategory& lhs, const CAMCategory& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CAMCategoryUpdate& lhs, const CAMCategoryUpdate& rhs);
inline bool operator!=(const CAMCategoryUpdate& lhs, const CAMCategoryUpdate& rhs) {
    return !(lhs == rhs);
}
bool operator==(const PoiAttribute& lhs, const PoiAttribute& rhs);
inline bool operator!=(const PoiAttribute& lhs, const PoiAttribute& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CategoryAndRadius& lhs, const CategoryAndRadius& rhs);
inline bool operator!=(const CategoryAndRadius& lhs, const CategoryAndRadius& rhs) {
    return !(lhs == rhs);
}
bool operator==(const PoiDetails& lhs, const PoiDetails& rhs);
inline bool operator!=(const PoiDetails& lhs, const PoiDetails& rhs) {
    return !(lhs == rhs);
}
bool operator==(const SearchResultDetails& lhs, const SearchResultDetails& rhs);
inline bool operator!=(const SearchResultDetails& lhs, const SearchResultDetails& rhs) {
    return !(lhs == rhs);
}
bool operator==(const SearchResult& lhs, const SearchResult& rhs);
inline bool operator!=(const SearchResult& lhs, const SearchResult& rhs) {
    return !(lhs == rhs);
}
bool operator==(const PoiCAMDetails& lhs, const PoiCAMDetails& rhs);
inline bool operator!=(const PoiCAMDetails& lhs, const PoiCAMDetails& rhs) {
    return !(lhs == rhs);
}
bool operator==(const AttributeDetails& lhs, const AttributeDetails& rhs);
inline bool operator!=(const AttributeDetails& lhs, const AttributeDetails& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CategoryDetails& lhs, const CategoryDetails& rhs);
inline bool operator!=(const CategoryDetails& lhs, const CategoryDetails& rhs) {
    return !(lhs == rhs);
}
bool operator==(const Category& lhs, const Category& rhs);
inline bool operator!=(const Category& lhs, const Category& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CategoryAndLevel& lhs, const CategoryAndLevel& rhs);
inline bool operator!=(const CategoryAndLevel& lhs, const CategoryAndLevel& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CategoryAndName& lhs, const CategoryAndName& rhs);
inline bool operator!=(const CategoryAndName& lhs, const CategoryAndName& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CategoryAndReason& lhs, const CategoryAndReason& rhs);
inline bool operator!=(const CategoryAndReason& lhs, const CategoryAndReason& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CategoryAndStatus& lhs, const CategoryAndStatus& rhs);
inline bool operator!=(const CategoryAndStatus& lhs, const CategoryAndStatus& rhs) {
    return !(lhs == rhs);
}
bool operator==(const PoiAddedDetails& lhs, const PoiAddedDetails& rhs);
inline bool operator!=(const PoiAddedDetails& lhs, const PoiAddedDetails& rhs) {
    return !(lhs == rhs);
}
bool operator==(const Locales& lhs, const Locales& rhs);
inline bool operator!=(const Locales& lhs, const Locales& rhs) {
    return !(lhs == rhs);
}


static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "org.genivi.navigation.poiservice.POIServiceTypes";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(0, 1);
}

} // namespace POIServiceTypes

} // namespace poiservice
} // namespace navigation
} // namespace genivi
} // namespace org

namespace CommonAPI {

    template<>
    struct BasicTypeWriter<org::genivi::navigation::poiservice::POIServiceTypes::SearchStatusState> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<org::genivi::navigation::poiservice::POIServiceTypes::SearchStatusState> {
        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::navigation::poiservice::POIServiceTypes::SearchStatusState>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<org::genivi::navigation::poiservice::POIServiceTypes::SearchStatusState> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::navigation::poiservice::POIServiceTypes::SearchStatusState>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };
    template<>
    struct BasicTypeWriter<org::genivi::navigation::poiservice::POIServiceTypes::AttributeType> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<org::genivi::navigation::poiservice::POIServiceTypes::AttributeType> {
        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::navigation::poiservice::POIServiceTypes::AttributeType>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<org::genivi::navigation::poiservice::POIServiceTypes::AttributeType> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::navigation::poiservice::POIServiceTypes::AttributeType>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };
    template<>
    struct BasicTypeWriter<org::genivi::navigation::poiservice::POIServiceTypes::OperatorType> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<org::genivi::navigation::poiservice::POIServiceTypes::OperatorType> {
        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::navigation::poiservice::POIServiceTypes::OperatorType>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<org::genivi::navigation::poiservice::POIServiceTypes::OperatorType> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::navigation::poiservice::POIServiceTypes::OperatorType>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };
    template<>
    struct BasicTypeWriter<org::genivi::navigation::poiservice::POIServiceTypes::UpdateReason> {
        inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
            typeStream.writeInt32EnumType();
        }
    };
    
    template<>
    struct InputStreamVectorHelper<org::genivi::navigation::poiservice::POIServiceTypes::UpdateReason> {
        static void beginReadVector(InputStream& inputStream, const std::vector<org::genivi::navigation::poiservice::POIServiceTypes::UpdateReason>& vectorValue) {
            inputStream.beginReadInt32EnumVector();
        }
    };
    
    template <>
    struct OutputStreamVectorHelper<org::genivi::navigation::poiservice::POIServiceTypes::UpdateReason> {
        static void beginWriteVector(OutputStream& outputStream, const std::vector<org::genivi::navigation::poiservice::POIServiceTypes::UpdateReason>& vectorValue) {
            outputStream.beginWriteInt32EnumVector(vectorValue.size());
        }
    };

}


namespace std {
    //Hash for SearchStatusState
    template<>
    struct hash<org::genivi::navigation::poiservice::POIServiceTypes::SearchStatusState> {
        inline size_t operator()(const org::genivi::navigation::poiservice::POIServiceTypes::SearchStatusState& searchStatusState) const {
            return static_cast<int32_t>(searchStatusState);
        }
    };
    //Hash for AttributeType
    template<>
    struct hash<org::genivi::navigation::poiservice::POIServiceTypes::AttributeType> {
        inline size_t operator()(const org::genivi::navigation::poiservice::POIServiceTypes::AttributeType& attributeType) const {
            return static_cast<int32_t>(attributeType);
        }
    };
    //Hash for OperatorType
    template<>
    struct hash<org::genivi::navigation::poiservice::POIServiceTypes::OperatorType> {
        inline size_t operator()(const org::genivi::navigation::poiservice::POIServiceTypes::OperatorType& operatorType) const {
            return static_cast<int32_t>(operatorType);
        }
    };
    //Hash for UpdateReason
    template<>
    struct hash<org::genivi::navigation::poiservice::POIServiceTypes::UpdateReason> {
        inline size_t operator()(const org::genivi::navigation::poiservice::POIServiceTypes::UpdateReason& updateReason) const {
            return static_cast<int32_t>(updateReason);
        }
    };
}

#endif // ORG_GENIVI_NAVIGATION_POISERVICE_POI_Service_Types_H_
